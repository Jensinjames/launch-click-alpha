import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.50.0";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface ExportRequest {
  contentId: string;
  format?: 'pdf' | 'docx';
  template?: 'default' | 'branded';
}

const supabase = createClient(
  Deno.env.get('SUPABASE_URL') ?? '',
  Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
);

// Simple PDF generation function using HTML to PDF conversion
async function generatePDF(content: any, template: string = 'default'): Promise<Uint8Array> {
  // For now, we'll create a simple HTML representation and convert to PDF
  // In production, you'd want to use a more sophisticated PDF library
  const html = createHTMLTemplate(content, template);
  
  // Using Puppeteer for PDF generation
  const response = await fetch('https://api.htmlcsstoimage.com/v1/image', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${Deno.env.get('HTMLCSS_API_KEY') || 'demo'}`,
    },
    body: JSON.stringify({
      html: html,
      css: getTemplateCSS(template),
      width: 800,
      height: 1200,
      format: 'pdf'
    })
  });

  if (!response.ok) {
    // Fallback: Create a simple text-based PDF-like content
    const textContent = createTextContent(content);
    return new TextEncoder().encode(textContent);
  }

  return new Uint8Array(await response.arrayBuffer());
}

function createHTMLTemplate(content: any, template: string): string {
  const title = content.title || 'Untitled Content';
  const contentText = typeof content.content === 'string' 
    ? content.content 
    : JSON.stringify(content.content, null, 2);
  
  const date = new Date().toLocaleDateString();
  
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <title>${title}</title>
    </head>
    <body>
      <header>
        <h1>${title}</h1>
        <p>Generated on ${date}</p>
        <p>Content Type: ${content.type || 'Unknown'}</p>
      </header>
      
      <main>
        <div class="content">
          ${formatContentForDisplay(contentText)}
        </div>
      </main>
      
      <footer>
        <p>Generated by LaunchClick Platform</p>
      </footer>
    </body>
    </html>
  `;
}

function getTemplateCSS(template: string): string {
  const baseCSS = `
    body {
      font-family: 'Helvetica', Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 800px;
      margin: 0 auto;
      padding: 40px 20px;
    }
    
    header {
      border-bottom: 3px solid #6366f1;
      padding-bottom: 20px;
      margin-bottom: 40px;
    }
    
    h1 {
      color: #1f2937;
      font-size: 2.5em;
      margin-bottom: 10px;
    }
    
    .content {
      white-space: pre-wrap;
      background: #f9fafb;
      padding: 30px;
      border-radius: 8px;
      border-left: 4px solid #6366f1;
    }
    
    footer {
      margin-top: 40px;
      padding-top: 20px;
      border-top: 1px solid #e5e7eb;
      text-align: center;
      color: #6b7280;
      font-size: 0.9em;
    }
  `;

  if (template === 'branded') {
    return baseCSS + `
      header::before {
        content: '';
        display: block;
        width: 100%;
        height: 100px;
        background: linear-gradient(135deg, #6366f1, #8b5cf6);
        margin: -40px -20px 20px -20px;
        border-radius: 0 0 8px 8px;
      }
    `;
  }

  return baseCSS;
}

function formatContentForDisplay(content: string): string {
  // Basic formatting for different content types
  try {
    const parsed = JSON.parse(content);
    if (typeof parsed === 'object') {
      return Object.entries(parsed)
        .map(([key, value]) => `<strong>${key}:</strong>\n${value}\n\n`)
        .join('');
    }
  } catch {
    // If not JSON, treat as plain text
  }
  
  return content.replace(/\n/g, '<br>');
}

function createTextContent(content: any): string {
  const title = content.title || 'Untitled Content';
  const contentText = typeof content.content === 'string' 
    ? content.content 
    : JSON.stringify(content.content, null, 2);
  
  return `
LaunchClick Content Export
${title}
${'='.repeat(title.length + 20)}

Generated: ${new Date().toLocaleString()}
Content Type: ${content.type || 'Unknown'}

Content:
${contentText}

---
Generated by LaunchClick Platform
  `;
}

const handler = async (req: Request): Promise<Response> => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { contentId, format = 'pdf', template = 'default' }: ExportRequest = await req.json();

    if (!contentId) {
      return new Response(
        JSON.stringify({ error: 'Content ID is required' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Get user from request
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response(
        JSON.stringify({ error: 'Authorization required' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Get user ID from JWT token
    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    
    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: 'Invalid authentication' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Create export job record
    const { data: exportJob, error: jobError } = await supabase
      .from('export_jobs')
      .insert({
        user_id: user.id,
        job_type: format,
        status: 'processing',
        content_ids: [contentId],
        metadata: { template, format }
      })
      .select()
      .single();

    if (jobError) {
      console.error('Error creating export job:', jobError);
      return new Response(
        JSON.stringify({ error: 'Failed to create export job' }),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Fetch the content
    const { data: content, error: contentError } = await supabase
      .from('generated_content')
      .select('*')
      .eq('id', contentId)
      .eq('user_id', user.id)
      .single();

    if (contentError || !content) {
      // Update job as failed
      await supabase
        .from('export_jobs')
        .update({ 
          status: 'failed', 
          error_message: 'Content not found or access denied',
          updated_at: new Date().toISOString()
        })
        .eq('id', exportJob.id);

      return new Response(
        JSON.stringify({ error: 'Content not found or access denied' }),
        { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    try {
      // Generate PDF
      const pdfBuffer = await generatePDF(content, template);
      
      // Upload to storage
      const fileName = `exports/${user.id}/${exportJob.id}_${content.title.replace(/[^a-zA-Z0-9]/g, '_')}.pdf`;
      const { data: uploadData, error: uploadError } = await supabase.storage
        .from('content-exports')
        .upload(fileName, pdfBuffer, {
          contentType: 'application/pdf',
          cacheControl: '3600'
        });

      if (uploadError) {
        throw new Error(`Upload failed: ${uploadError.message}`);
      }

      // Get public URL
      const { data: urlData } = supabase.storage
        .from('content-exports')
        .getPublicUrl(fileName);

      // Update export job as completed
      await supabase
        .from('export_jobs')
        .update({
          status: 'completed',
          file_url: urlData.publicUrl,
          file_size: pdfBuffer.length,
          completed_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .eq('id', exportJob.id);

      return new Response(
        JSON.stringify({
          success: true,
          jobId: exportJob.id,
          downloadUrl: urlData.publicUrl,
          fileName: fileName.split('/').pop()
        }),
        { 
          status: 200, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
        }
      );

    } catch (error) {
      console.error('Export processing error:', error);
      
      // Update job as failed
      await supabase
        .from('export_jobs')
        .update({
          status: 'failed',
          error_message: error instanceof Error ? error.message : 'Unknown error',
          updated_at: new Date().toISOString()
        })
        .eq('id', exportJob.id);

      return new Response(
        JSON.stringify({ error: 'Export processing failed' }),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

  } catch (error) {
    console.error('Error in export-content-pdf function:', error);
    return new Response(
      JSON.stringify({ error: 'Internal server error' }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
};

serve(handler);