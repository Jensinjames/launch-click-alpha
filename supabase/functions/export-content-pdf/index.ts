import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.50.0";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface ExportRequest {
  contentId: string;
  format?: 'pdf' | 'docx';
  template?: 'default' | 'branded';
}

const supabase = createClient(
  Deno.env.get('SUPABASE_URL') ?? '',
  Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
);

// Enhanced PDF generation function with proper error handling
async function generatePDF(content: any, template: string = 'default'): Promise<Uint8Array> {
  console.log('Starting PDF generation:', { template, contentType: content.type });
  
  try {
    const html = createHTMLTemplate(content, template);
    const css = getTemplateCSS(template);
    
    console.log('Generated HTML template length:', html.length);
    
    // Try using HTMLCSStoImage API for PDF generation
    const htmlCssApiKey = Deno.env.get('HTMLCSS_API_KEY');
    
    if (htmlCssApiKey && htmlCssApiKey !== 'demo') {
      console.log('Attempting PDF generation via HTMLCSStoImage API');
      
      const response = await fetch('https://api.htmlcsstoimage.com/v1/image', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${htmlCssApiKey}`,
        },
        body: JSON.stringify({
          html: html,
          css: css,
          width: 800,
          height: 1200,
          format: 'pdf'
        })
      });

      if (response.ok) {
        console.log('PDF generated successfully via API');
        return new Uint8Array(await response.arrayBuffer());
      } else {
        console.warn('HTMLCSStoImage API failed:', response.status, await response.text());
      }
    } else {
      console.log('HTMLCSStoImage API key not configured, using fallback');
    }
    
    // Fallback: Create enhanced HTML-based PDF content
    const enhancedContent = createEnhancedHTMLContent(content, template);
    return new TextEncoder().encode(enhancedContent);
    
  } catch (error) {
    console.error('PDF generation error:', error);
    // Final fallback: Create simple text content
    const textContent = createTextContent(content);
    return new TextEncoder().encode(textContent);
  }
}

function createHTMLTemplate(content: any, template: string): string {
  const title = content.title || 'Untitled Content';
  const contentText = typeof content.content === 'string' 
    ? content.content 
    : JSON.stringify(content.content, null, 2);
  
  const date = new Date().toLocaleDateString();
  
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <title>${title}</title>
    </head>
    <body>
      <header>
        <h1>${title}</h1>
        <p>Generated on ${date}</p>
        <p>Content Type: ${content.type || 'Unknown'}</p>
      </header>
      
      <main>
        <div class="content">
          ${formatContentForDisplay(contentText)}
        </div>
      </main>
      
      <footer>
        <p>Generated by LaunchClick Platform</p>
      </footer>
    </body>
    </html>
  `;
}

function getTemplateCSS(template: string): string {
  const baseCSS = `
    body {
      font-family: 'Helvetica', Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 800px;
      margin: 0 auto;
      padding: 40px 20px;
    }
    
    header {
      border-bottom: 3px solid #6366f1;
      padding-bottom: 20px;
      margin-bottom: 40px;
    }
    
    h1 {
      color: #1f2937;
      font-size: 2.5em;
      margin-bottom: 10px;
    }
    
    .content {
      white-space: pre-wrap;
      background: #f9fafb;
      padding: 30px;
      border-radius: 8px;
      border-left: 4px solid #6366f1;
    }
    
    footer {
      margin-top: 40px;
      padding-top: 20px;
      border-top: 1px solid #e5e7eb;
      text-align: center;
      color: #6b7280;
      font-size: 0.9em;
    }
  `;

  if (template === 'branded') {
    return baseCSS + `
      header::before {
        content: '';
        display: block;
        width: 100%;
        height: 100px;
        background: linear-gradient(135deg, #6366f1, #8b5cf6);
        margin: -40px -20px 20px -20px;
        border-radius: 0 0 8px 8px;
      }
    `;
  }

  return baseCSS;
}

function formatContentForDisplay(content: string): string {
  // Basic formatting for different content types
  try {
    const parsed = JSON.parse(content);
    if (typeof parsed === 'object') {
      return Object.entries(parsed)
        .map(([key, value]) => `<strong>${key}:</strong>\n${value}\n\n`)
        .join('');
    }
  } catch {
    // If not JSON, treat as plain text
  }
  
  return content.replace(/\n/g, '<br>');
}

function createEnhancedHTMLContent(content: any, template: string): string {
  const title = content.title || 'Untitled Content';
  const contentText = typeof content.content === 'string' 
    ? content.content 
    : JSON.stringify(content.content, null, 2);
  
  const date = new Date().toLocaleDateString();
  
  return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>${title}</title>
  <style>
    ${getTemplateCSS(template)}
    @media print {
      body { margin: 0; padding: 20px; }
      .no-print { display: none; }
    }
  </style>
</head>
<body>
  <header>
    <h1>${title}</h1>
    <p>Generated on ${date}</p>
    <p>Content Type: ${content.type || 'Unknown'}</p>
  </header>
  
  <main>
    <div class="content">
      ${formatContentForDisplay(contentText)}
    </div>
  </main>
  
  <footer>
    <p>Generated by LaunchClick Platform</p>
  </footer>
</body>
</html>
  `;
}

function createTextContent(content: any): string {
  const title = content.title || 'Untitled Content';
  const contentText = typeof content.content === 'string' 
    ? content.content 
    : JSON.stringify(content.content, null, 2);
  
  return `
LaunchClick Content Export
${title}
${'='.repeat(title.length + 20)}

Generated: ${new Date().toLocaleString()}
Content Type: ${content.type || 'Unknown'}

Content:
${contentText}

---
Generated by LaunchClick Platform
  `;
}

const handler = async (req: Request): Promise<Response> => {
  const startTime = Date.now();
  const requestId = globalThis.crypto.randomUUID();
  
  console.log(`[${requestId}] Export PDF request started`, {
    method: req.method,
    timestamp: new Date().toISOString()
  });
  
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    console.log(`[${requestId}] CORS preflight request handled`);
    return new Response(null, { headers: corsHeaders });
  }

  try {
    // Parse request body with detailed logging
    let requestBody: any;
    try {
      requestBody = await req.json();
      console.log(`[${requestId}] Request body parsed:`, requestBody);
    } catch (parseError) {
      console.error(`[${requestId}] Failed to parse request body:`, parseError);
      return new Response(
        JSON.stringify({ error: 'Invalid JSON in request body', requestId }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }
    
    const { contentId, format = 'pdf', template = 'default' }: ExportRequest = requestBody;

    if (!contentId) {
      console.error(`[${requestId}] Missing contentId in request:`, requestBody);
      return new Response(
        JSON.stringify({ error: 'Content ID is required', requestId }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    console.log(`[${requestId}] Processing export for contentId: ${contentId}, format: ${format}, template: ${template}`);

    // Get user from request
    const authHeader = req.headers.get('Authorization');
    console.log(`[${requestId}] Auth header present:`, !!authHeader);
    
    if (!authHeader) {
      console.error(`[${requestId}] Missing Authorization header`);
      return new Response(
        JSON.stringify({ error: 'Authorization required', requestId }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Get user ID from JWT token
    const token = authHeader.replace('Bearer ', '');
    console.log(`[${requestId}] Attempting to verify user token`);
    
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    
    if (authError || !user) {
      console.error(`[${requestId}] Authentication failed:`, authError);
      return new Response(
        JSON.stringify({ error: 'Invalid authentication', requestId, details: authError?.message }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    console.log(`[${requestId}] User authenticated successfully:`, user.id);

    // Check feature access
    const { data: userPlan, error: planError } = await supabase
      .from('user_plans')
      .select('plan_type')
      .eq('user_id', user.id)
      .single();

    if (planError) {
      console.error(`[${requestId}] Failed to fetch user plan:`, planError);
    } else {
      console.log(`[${requestId}] User plan:`, userPlan?.plan_type);
    }

    // Check feature access for content_export_pdf
    const { data: hasAccess, error: accessError } = await supabase
      .rpc('can_access_feature', { 
        feature_name: 'content_export_pdf', 
        check_user_id: user.id 
      });

    if (accessError) {
      console.error(`[${requestId}] Feature access check failed:`, accessError);
      return new Response(
        JSON.stringify({ error: 'Feature access verification failed', requestId, details: accessError.message }),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (!hasAccess) {
      console.warn(`[${requestId}] User ${user.id} lacks access to content_export_pdf feature. Plan: ${userPlan?.plan_type}`);
      return new Response(
        JSON.stringify({ 
          error: 'PDF export requires Pro plan or higher', 
          requestId,
          currentPlan: userPlan?.plan_type || 'unknown',
          upgradeRequired: true
        }),
        { status: 403, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    console.log(`[${requestId}] Feature access verified successfully`);

    // Create export job record
    console.log(`[${requestId}] Creating export job record`);
    const { data: exportJob, error: jobError } = await supabase
      .from('export_jobs')
      .insert({
        user_id: user.id,
        job_type: format,
        status: 'processing',
        content_ids: [contentId],
        metadata: { template, format, requestId }
      })
      .select()
      .single();

    if (jobError) {
      console.error(`[${requestId}] Error creating export job:`, jobError);
      return new Response(
        JSON.stringify({ error: 'Failed to create export job', requestId, details: jobError.message }),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    console.log(`[${requestId}] Export job created:`, exportJob.id);

    // Fetch the content
    console.log(`[${requestId}] Fetching content for ID: ${contentId}`);
    const { data: content, error: contentError } = await supabase
      .from('generated_content')
      .select('*')
      .eq('id', contentId)
      .eq('user_id', user.id)
      .single();

    if (contentError || !content) {
      console.error(`[${requestId}] Content fetch failed:`, contentError);
      // Update job as failed
      await supabase
        .from('export_jobs')
        .update({ 
          status: 'failed', 
          error_message: 'Content not found or access denied',
          updated_at: new Date().toISOString()
        })
        .eq('id', exportJob.id);

      return new Response(
        JSON.stringify({ error: 'Content not found or access denied', requestId, details: contentError?.message }),
        { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    console.log(`[${requestId}] Content fetched successfully:`, {
      id: content.id,
      title: content.title,
      type: content.type,
      contentSize: JSON.stringify(content.content).length
    });

    try {
      // Generate PDF
      console.log(`[${requestId}] Starting PDF generation`);
      const pdfGenStart = Date.now();
      const pdfBuffer = await generatePDF(content, template);
      const pdfGenTime = Date.now() - pdfGenStart;
      
      console.log(`[${requestId}] PDF generated successfully:`, {
        size: pdfBuffer.length,
        generationTimeMs: pdfGenTime
      });
      
      // Upload to storage
      const fileName = `exports/${user.id}/${exportJob.id}_${content.title.replace(/[^a-zA-Z0-9]/g, '_')}.pdf`;
      console.log(`[${requestId}] Uploading to storage:`, fileName);
      
      const { data: uploadData, error: uploadError } = await supabase.storage
        .from('content-exports')
        .upload(fileName, pdfBuffer, {
          contentType: 'application/pdf',
          cacheControl: '3600'
        });

      if (uploadError) {
        throw new Error(`Upload failed: ${uploadError.message}`);
      }

      console.log(`[${requestId}] Upload successful:`, uploadData);

      // Get public URL
      const { data: urlData } = supabase.storage
        .from('content-exports')
        .getPublicUrl(fileName);

      console.log(`[${requestId}] Public URL generated:`, urlData.publicUrl);

      // Update export job as completed
      await supabase
        .from('export_jobs')
        .update({
          status: 'completed',
          file_url: urlData.publicUrl,
          file_size: pdfBuffer.length,
          completed_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .eq('id', exportJob.id);

      const totalTime = Date.now() - startTime;
      console.log(`[${requestId}] Export completed successfully:`, {
        totalTimeMs: totalTime,
        pdfGenerationTimeMs: pdfGenTime,
        fileSize: pdfBuffer.length,
        downloadUrl: urlData.publicUrl
      });

      return new Response(
        JSON.stringify({
          success: true,
          jobId: exportJob.id,
          file_url: urlData.publicUrl,
          downloadUrl: urlData.publicUrl,
          fileName: fileName.split('/').pop(),
          requestId,
          metrics: {
            totalTimeMs: totalTime,
            pdfGenerationTimeMs: pdfGenTime,
            fileSize: pdfBuffer.length
          }
        }),
        { 
          status: 200, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
        }
      );

    } catch (error) {
      console.error(`[${requestId}] Export processing error:`, error);
      
      // Update job as failed
      await supabase
        .from('export_jobs')
        .update({
          status: 'failed',
          error_message: error instanceof Error ? error.message : 'Unknown error',
          updated_at: new Date().toISOString()
        })
        .eq('id', exportJob.id);

      return new Response(
        JSON.stringify({ 
          error: 'Export processing failed', 
          requestId,
          details: error instanceof Error ? error.message : 'Unknown error'
        }),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

  } catch (error) {
    const totalTime = Date.now() - startTime;
    console.error(`[${requestId}] Unhandled error in export-content-pdf function:`, {
      error,
      totalTimeMs: totalTime,
      timestamp: new Date().toISOString()
    });
    
    return new Response(
      JSON.stringify({ 
        error: 'Internal server error', 
        requestId,
        details: error instanceof Error ? error.message : 'Unknown error'
      }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
};

serve(handler);